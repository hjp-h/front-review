##  JS知识

### 1.AJAX

#### 1.1什么是ajax

- 异步的javaScript和Xml，实现局部的页面动态刷新

#### 1.2 ajax的优点

- **实现局部的刷新**，提升了用户体验。
- 优化了浏览器与服务器之间的传输，减少了不必要的数据往返，**降低了宽带的使用**。
- ajax在客户端运行，，减轻了服务器的负载。

#### 1.3 ajax的实现过程

- 创建xmlHttpRequest()对象

  ```javascript
  var xhr = new XMLHttpRequest()
  ```

- 创建http请求

  ```javascript
  xhr.open("get",url,true)
  ```

- 发送请求

  ```javascript
  xhr.send()
  ```

  

- 获取异步调用返回的数据

  ```javascript
  xhr.onreadystatechange = function() {
      if(xhr.onreadyState === 4) {
          if(xhr.status === 200){
              console.log(xhr.responseText)
          }
      }
  }
  ```

#### 1.4 ajax的不足

- 无法操作back按钮
- 安全问题 ajax暴露了与服务器交互的细节
- 不容易测试
- 破坏了程序的异常机制
- 对搜索引擎的支持比较弱

#### 1.5 ajax同步与异步的区别

- 同步：提交请求后，等待服务器的处理，这个过程中不允许浏览器干别的事情
- 异步：提交请求后，在等待服务武器处理数据的同时可以干别的事情
- ajax.open()的第三个参数设置是同步还是异步。

#### 1.6跨域解决的方法

- jsonp：通过script标签发送请求，因此此标签不受同源政策的限制，支持跨域访问，操作为script标签内给服务器发送一个callback的函数，但是这个函数必须提前定义好。
- 配置代理proxy
- 跨域资源共享：设置cros,设置Access-Control-Allow-Origin

### 2.事件流

### 3.Promise

### 4.深拷贝浅拷贝

### 5.new做了什么

### 6.浏览器是怎么渲染出页面的

#### 6.1 浏览器的内核

![image-20210510155256877](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210510155256877.png)

#### 6.2浏览器是怎么渲染出页面的

![image-20210510155407575](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210510155407575.png)

### 7.async、await

### 8.事件循环

### 9.JS模块化

#### 	9.1 什么是模块化

1. 将程序划分成一个一个的小结构，这些结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他结构
2. 当每个结构中有一些比较好的函数，变量、对象其他结构需要使用时，可以将其暴露出来，其他结构导入即可
3. 上面说到的结构就是模块，按照这种结构划分开发的过程就是模块化开发的过程

### 10、赋值

- 对象会在堆内存开辟一个空间

### 11.设计模式

- 创建型模式

  ```
  用来描述“如何创建对象”，它的主要特点就是将对象的创建和使用分离。
  ```

  1. 单例模式

     ```
     有一些对象我们只需要一个，比如全局缓存，浏览器的window对象，单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。
     ```

  2. 简单工厂模式

     ```
     它又叫做静态方法模式，工厂类中定义了一个静态方法用于创建对象，让使用者不需要知道产品的具体生产细节。（只需要提供汽车的型号，工厂会根据提供的型号来判断造车，每一个型号对应一个类）
     ```

  3. 抽象工厂模式

     ```
     提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。（先有一个抽象类包含了所有的方法，再指定一个实体类去继承这个抽象类实现其中的方法）
     ```

  4. 工厂方法模式

     ```
     它又叫多态工厂模式，工厂方法的父类负责定义创建产品的公共接口，而工厂子类负责生成具体的对象，这样做的目的是将产品的实例化操作延迟到子类工厂中完成。（需要知道汽车的型号对应哪个工厂，工厂会根据提供的型号来判断造车，每一个型号对应一个类）
     ```

     

- 结构型模式

  ```
  用来描述如何将类或对象按照某种布局组成更大的结构。
  ```

  1. 适配器模式

     ```
     解决两个软件实体间的接口不兼容的问题
     ```

     

- 行为型模式

  ```
  用来识别对象之间的常用交流模式以及如何分配职责。
  ```

  1. 策略型模式

     ```
     定义了一系列的算法，把它们一个个封装起来，并且使他们可以相互的替换。（例如登录的多种选择）
     ```

  2. 职责链模式

     ```
     每个对象都有处理请求的机会，只是根据权限的大小来分配不同的职责。（例如请假按照不同的天数给不同的领导审批）
     ```

  3. 观察者模式

     ```
     定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得他们能够自动更新自己。
     ```

  4. 发布订阅模式

     ````
     是一种消息范式，发布者将消息分为不同的类别，通过通道，发给订阅了对应消息类别的订阅者。
     ````


### 12.数组和对象的遍历

- 为什么数组的遍历是有序的，而对象的遍历是无序的？

  ```
  Chrome Opera 中使用 for-in 语句遍历对象属性时会遵循一个规律：
  它们会先提取所有 key 的 parseFloat 值为非负整数的属性，然后根据数字顺序对属性排序首先遍历出来，然后按照对象定义的顺序遍历余下的所有属性。
  
  那么，解决办法呢？
  可以把对象通过Object.keys提取对象的key出来变成数组，然后通过数组的排序，然后遍历数组，通过key去取对象的属性值。
  ```

  